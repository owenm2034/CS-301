# Amdahl’s Law

Amdahl's Law is a formula that predicts the potential speed increase in completing a task with improved system resources while keeping the workload constant. The theoretical speedup is always limited by the part of the task that cannot benefit from the improvement.

$$
\text{Speed Up = }\frac{\text{Execution Time by Single Processor}}{\text{Execution Time by $N$ processors}}\\=\frac{T(1-f)+Tf}{T(1-f) +\frac{Tf}{N}}\\=\frac{(1-f)+f}{(1-f)+\frac{f}{N}}\\=\frac{1}{(1-f)+\frac{f}{N}}
$$

$$
\text{1. Speed}=\lim_{f\rightarrow 0}=\frac{1}{(1-f)+\frac{f}{N}}\\=\frac{1}{1-0+\frac{0}{N}}=1 \Rightarrow \text{\textbf{No Improvement}}\\ \text{2. Speed }=\lim_{N\rightarrow \infty}=\frac{1}{(1-f)+\frac{f}{N}}=\frac{1}{1-f}\Rightarrow \text{\textbf{Improvement, but bounded}}
$$

We don’t seem to want either of these, so let’s move to…*multithreading*(?)

$$
\text{3. Speed }=\lim_{f\rightarrow 1}=\frac{1}{1-f+\frac{f}{N}}=N
$$

Multithreading Def: *(from Google)* Multithreading is the ability of a central processing unit (CPU) (or a single core in a multi-core processor) to provide multiple threads of execution concurrently, supported by the operating system.

$$
\text{Speed Up }=\frac{\text{Performance of SS}}{\text{Performance of S}}\\\Rightarrow\frac{\text{Performance after enhancement}}{\text{Performance before enhancement}}\\\text{Since Performance }\alpha\frac{1}{t}\text{ (i.e. performance is the inverse of time)}\\\Rightarrow\frac{\text{Time after enhancement}}{\text{Time before enhancement}}
$$

If speed up < 1, performance has declined, if it’s = 1, no change, and if its > 1 then an improvement has taken place.

## Clock Rate

*From Textbook Pg. 71 (73 on pdf):*

Typically, clock signals are generated by a quartz crystal, which generates a
constant sine wave while power is applied. This wave is converted into a digital
voltage pulse stream that is provided in a constant flow to the processor circuitry
(Figure 2.5). For example, a 1-GHz processor receives 1 billion pulses per second.
The rate of pulses is known as the **clock rate**, or **clock speed**. One increment, or
pulse, of the clock is referred to as a **clock cycle**, or a **clock tick**. The time between
pulses is the **cycle time**.

![Screen Shot 2024-02-01 at 5.24.22 PM.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/29c217b6-c6d3-4fdf-a256-04d09c788159/20a376fc-3673-46b5-ae49-792034179ab3/Screen_Shot_2024-02-01_at_5.24.22_PM.png)

*Recall:* RISC: **fetching, decoding, loading, execution, and storing when performing instructions on a CPU (4 cycles). Also RISC has fewer, more specific registers, and CISC has many many general use processors (50:1000) *I think*

*look up 555 Timer (integrated circuit)

Application Programming:

- Instruction Set
- Language
- Compiler Efficiency (high-level to assembly, and assembly to machine code)
- Programmer Skill

## Instruction Execute Rate

*From Textbook Pg. 72 (74 on pdf):*

(Note: when “t” is used, its used instead of tau, the greek letter)

A processor is driven by a clock with a constant frequency f or, equivalently, a constant cycle time t, where t = 1/f. Define the instruction count, Ic, for a program as
the number of machine instructions executed for that program until it runs to completion or for some defined time interval. Note that this is the number of instruction
executions, not the number of instructions in the object code of the program. An
important parameter is the average cycles per instruction (CPI) for a program. If all
instructions required the same number of clock cycles, then CPI would be a constant
value for a processor. However, on any given processor, the number of clock cycles
required varies for different types of instructions, such as load, store, branch, and so
on. Let CPIi be the number of cycles required for instruction type i, and Ii be the
number of executed instructions of type i for a given program. Then we can calculate
an overall CPI as follows: (Avg. CPI given from textbook, rest given in class)

$$
f=\text{No. of cycles per second}\\\tau=\frac{1}{f}=\text{Time for each cycle}\\I_C=\text{Total no. of instructions}\\CPI=\text{Cycles per instructions}\\\text{Avg. }CPI=\frac{\sum^{n}_{i=1}(CPI_i\times I_i)}{I_C}\\\text{Total no. of cycles needed }=CPI\times I_C\\\text{Total amount of time needed }=CPI\times I_C\times \tau\\\text{No. of instructions executed }=\frac{1}{CPI\times \tau}
$$

The processor time T needed to execute a given program can be expressed as